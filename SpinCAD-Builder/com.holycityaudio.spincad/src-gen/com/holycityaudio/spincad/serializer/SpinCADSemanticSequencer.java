/*
 * generated by Xtext
 */
package com.holycityaudio.spincad.serializer;

import com.google.inject.Inject;
import com.holycityaudio.spincad.services.SpinCADGrammarAccess;
import com.holycityaudio.spincad.spinCAD.Absa;
import com.holycityaudio.spincad.spinCAD.And;
import com.holycityaudio.spincad.spinCAD.AudioInput;
import com.holycityaudio.spincad.spinCAD.AudioOutput;
import com.holycityaudio.spincad.spinCAD.ChorusReadDelay;
import com.holycityaudio.spincad.spinCAD.ChorusReadValue;
import com.holycityaudio.spincad.spinCAD.ChorusScaleOffset;
import com.holycityaudio.spincad.spinCAD.Clr;
import com.holycityaudio.spincad.spinCAD.Comment;
import com.holycityaudio.spincad.spinCAD.ControlInput;
import com.holycityaudio.spincad.spinCAD.ControlOutput;
import com.holycityaudio.spincad.spinCAD.DivideDouble;
import com.holycityaudio.spincad.spinCAD.DivideInt;
import com.holycityaudio.spincad.spinCAD.Equals;
import com.holycityaudio.spincad.spinCAD.EqualsBool;
import com.holycityaudio.spincad.spinCAD.Exp;
import com.holycityaudio.spincad.spinCAD.GetBaseAddress;
import com.holycityaudio.spincad.spinCAD.GetDelayScaleControl;
import com.holycityaudio.spincad.spinCAD.GetInputDefault;
import com.holycityaudio.spincad.spinCAD.GetSamplesFromRatio;
import com.holycityaudio.spincad.spinCAD.IsElse;
import com.holycityaudio.spincad.spinCAD.IsEndif;
import com.holycityaudio.spincad.spinCAD.IsEqualTo;
import com.holycityaudio.spincad.spinCAD.IsGreaterThan;
import com.holycityaudio.spincad.spinCAD.IsLessThan;
import com.holycityaudio.spincad.spinCAD.IsOr;
import com.holycityaudio.spincad.spinCAD.IsPinConnected;
import com.holycityaudio.spincad.spinCAD.IsTrue;
import com.holycityaudio.spincad.spinCAD.Jam;
import com.holycityaudio.spincad.spinCAD.Label;
import com.holycityaudio.spincad.spinCAD.Ldax;
import com.holycityaudio.spincad.spinCAD.LoadRampLFO;
import com.holycityaudio.spincad.spinCAD.LoadSinLFO;
import com.holycityaudio.spincad.spinCAD.Log;
import com.holycityaudio.spincad.spinCAD.LogFreq2SliderLabel;
import com.holycityaudio.spincad.spinCAD.LogFreqSliderLabel;
import com.holycityaudio.spincad.spinCAD.Maxx;
import com.holycityaudio.spincad.spinCAD.Mem;
import com.holycityaudio.spincad.spinCAD.MinusDouble;
import com.holycityaudio.spincad.spinCAD.MultiplyDouble;
import com.holycityaudio.spincad.spinCAD.Mulx;
import com.holycityaudio.spincad.spinCAD.Not;
import com.holycityaudio.spincad.spinCAD.Offset;
import com.holycityaudio.spincad.spinCAD.Or;
import com.holycityaudio.spincad.spinCAD.Program;
import com.holycityaudio.spincad.spinCAD.ReadChorusTap;
import com.holycityaudio.spincad.spinCAD.ReadDelay;
import com.holycityaudio.spincad.spinCAD.ReadDelayPointer;
import com.holycityaudio.spincad.spinCAD.ReadRegister;
import com.holycityaudio.spincad.spinCAD.ReadRegisterFilter;
import com.holycityaudio.spincad.spinCAD.SPINMEM;
import com.holycityaudio.spincad.spinCAD.ScaleOffset;
import com.holycityaudio.spincad.spinCAD.SemitonesToRmpRate;
import com.holycityaudio.spincad.spinCAD.SetChorusWidth;
import com.holycityaudio.spincad.spinCAD.SetOutputPin;
import com.holycityaudio.spincad.spinCAD.Skip;
import com.holycityaudio.spincad.spinCAD.SliderLabelCheckBox;
import com.holycityaudio.spincad.spinCAD.SliderLabelSpinner;
import com.holycityaudio.spincad.spinCAD.SpinBool;
import com.holycityaudio.spincad.spinCAD.SpinCADPackage;
import com.holycityaudio.spincad.spinCAD.SpinCheckBox;
import com.holycityaudio.spincad.spinCAD.SpinComboBox;
import com.holycityaudio.spincad.spinCAD.SpinEquate;
import com.holycityaudio.spincad.spinCAD.SpinInt;
import com.holycityaudio.spincad.spinCAD.SpinRadioButton;
import com.holycityaudio.spincad.spinCAD.SpinSliderLabel;
import com.holycityaudio.spincad.spinCAD.WriteAllpass;
import com.holycityaudio.spincad.spinCAD.WriteDelay;
import com.holycityaudio.spincad.spinCAD.WriteRegister;
import com.holycityaudio.spincad.spinCAD.WriteRegisterHighshelf;
import com.holycityaudio.spincad.spinCAD.WriteRegisterLowshelf;
import com.holycityaudio.spincad.spinCAD.Xor;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class SpinCADSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SpinCADGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SpinCADPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SpinCADPackage.ABSA:
				sequence_Absa(context, (Absa) semanticObject); 
				return; 
			case SpinCADPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case SpinCADPackage.AUDIO_INPUT:
				sequence_AudioInput(context, (AudioInput) semanticObject); 
				return; 
			case SpinCADPackage.AUDIO_OUTPUT:
				sequence_AudioOutput(context, (AudioOutput) semanticObject); 
				return; 
			case SpinCADPackage.CHORUS_READ_DELAY:
				sequence_ChorusReadDelay(context, (ChorusReadDelay) semanticObject); 
				return; 
			case SpinCADPackage.CHORUS_READ_VALUE:
				sequence_ChorusReadValue(context, (ChorusReadValue) semanticObject); 
				return; 
			case SpinCADPackage.CHORUS_SCALE_OFFSET:
				sequence_ChorusScaleOffset(context, (ChorusScaleOffset) semanticObject); 
				return; 
			case SpinCADPackage.CLR:
				sequence_Clr(context, (Clr) semanticObject); 
				return; 
			case SpinCADPackage.COMMENT:
				sequence_Comment(context, (Comment) semanticObject); 
				return; 
			case SpinCADPackage.CONTROL_INPUT:
				sequence_ControlInput(context, (ControlInput) semanticObject); 
				return; 
			case SpinCADPackage.CONTROL_OUTPUT:
				sequence_ControlOutput(context, (ControlOutput) semanticObject); 
				return; 
			case SpinCADPackage.DIVIDE_DOUBLE:
				sequence_DivideDouble(context, (DivideDouble) semanticObject); 
				return; 
			case SpinCADPackage.DIVIDE_INT:
				sequence_DivideInt(context, (DivideInt) semanticObject); 
				return; 
			case SpinCADPackage.EQUALS:
				sequence_Equals(context, (Equals) semanticObject); 
				return; 
			case SpinCADPackage.EQUALS_BOOL:
				sequence_EqualsBool(context, (EqualsBool) semanticObject); 
				return; 
			case SpinCADPackage.EXP:
				sequence_Exp(context, (Exp) semanticObject); 
				return; 
			case SpinCADPackage.GET_BASE_ADDRESS:
				sequence_GetBaseAddress(context, (GetBaseAddress) semanticObject); 
				return; 
			case SpinCADPackage.GET_DELAY_SCALE_CONTROL:
				sequence_GetDelayScaleControl(context, (GetDelayScaleControl) semanticObject); 
				return; 
			case SpinCADPackage.GET_INPUT_DEFAULT:
				sequence_GetInputDefault(context, (GetInputDefault) semanticObject); 
				return; 
			case SpinCADPackage.GET_SAMPLES_FROM_RATIO:
				sequence_GetSamplesFromRatio(context, (GetSamplesFromRatio) semanticObject); 
				return; 
			case SpinCADPackage.IS_ELSE:
				sequence_IsElse(context, (IsElse) semanticObject); 
				return; 
			case SpinCADPackage.IS_ENDIF:
				sequence_IsEndif(context, (IsEndif) semanticObject); 
				return; 
			case SpinCADPackage.IS_EQUAL_TO:
				sequence_IsEqualTo(context, (IsEqualTo) semanticObject); 
				return; 
			case SpinCADPackage.IS_GREATER_THAN:
				sequence_IsGreaterThan(context, (IsGreaterThan) semanticObject); 
				return; 
			case SpinCADPackage.IS_LESS_THAN:
				sequence_IsLessThan(context, (IsLessThan) semanticObject); 
				return; 
			case SpinCADPackage.IS_OR:
				sequence_IsOr(context, (IsOr) semanticObject); 
				return; 
			case SpinCADPackage.IS_PIN_CONNECTED:
				sequence_IsPinConnected(context, (IsPinConnected) semanticObject); 
				return; 
			case SpinCADPackage.IS_TRUE:
				sequence_IsTrue(context, (IsTrue) semanticObject); 
				return; 
			case SpinCADPackage.JAM:
				sequence_Jam(context, (Jam) semanticObject); 
				return; 
			case SpinCADPackage.LABEL:
				sequence_Label(context, (Label) semanticObject); 
				return; 
			case SpinCADPackage.LDAX:
				sequence_Ldax(context, (Ldax) semanticObject); 
				return; 
			case SpinCADPackage.LOAD_RAMP_LFO:
				sequence_LoadRampLFO(context, (LoadRampLFO) semanticObject); 
				return; 
			case SpinCADPackage.LOAD_SIN_LFO:
				sequence_LoadSinLFO(context, (LoadSinLFO) semanticObject); 
				return; 
			case SpinCADPackage.LOG:
				sequence_Log(context, (Log) semanticObject); 
				return; 
			case SpinCADPackage.LOG_FREQ2_SLIDER_LABEL:
				sequence_LogFreq2SliderLabel(context, (LogFreq2SliderLabel) semanticObject); 
				return; 
			case SpinCADPackage.LOG_FREQ_SLIDER_LABEL:
				sequence_LogFreqSliderLabel(context, (LogFreqSliderLabel) semanticObject); 
				return; 
			case SpinCADPackage.MAXX:
				sequence_Maxx(context, (Maxx) semanticObject); 
				return; 
			case SpinCADPackage.MEM:
				sequence_Mem(context, (Mem) semanticObject); 
				return; 
			case SpinCADPackage.MINUS_DOUBLE:
				sequence_MinusDouble(context, (MinusDouble) semanticObject); 
				return; 
			case SpinCADPackage.MULTIPLY_DOUBLE:
				sequence_MultiplyDouble(context, (MultiplyDouble) semanticObject); 
				return; 
			case SpinCADPackage.MULX:
				sequence_Mulx(context, (Mulx) semanticObject); 
				return; 
			case SpinCADPackage.NOT:
				sequence_Not(context, (Not) semanticObject); 
				return; 
			case SpinCADPackage.OFFSET:
				sequence_Offset(context, (Offset) semanticObject); 
				return; 
			case SpinCADPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case SpinCADPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case SpinCADPackage.READ_CHORUS_TAP:
				sequence_ReadChorusTap(context, (ReadChorusTap) semanticObject); 
				return; 
			case SpinCADPackage.READ_DELAY:
				sequence_ReadDelay(context, (ReadDelay) semanticObject); 
				return; 
			case SpinCADPackage.READ_DELAY_POINTER:
				sequence_ReadDelayPointer(context, (ReadDelayPointer) semanticObject); 
				return; 
			case SpinCADPackage.READ_REGISTER:
				sequence_ReadRegister(context, (ReadRegister) semanticObject); 
				return; 
			case SpinCADPackage.READ_REGISTER_FILTER:
				sequence_ReadRegisterFilter(context, (ReadRegisterFilter) semanticObject); 
				return; 
			case SpinCADPackage.SPINMEM:
				sequence_SPINMEM(context, (SPINMEM) semanticObject); 
				return; 
			case SpinCADPackage.SCALE_OFFSET:
				sequence_ScaleOffset(context, (ScaleOffset) semanticObject); 
				return; 
			case SpinCADPackage.SEMITONES_TO_RMP_RATE:
				sequence_SemitonesToRmpRate(context, (SemitonesToRmpRate) semanticObject); 
				return; 
			case SpinCADPackage.SET_CHORUS_WIDTH:
				sequence_SetChorusWidth(context, (SetChorusWidth) semanticObject); 
				return; 
			case SpinCADPackage.SET_OUTPUT_PIN:
				sequence_SetOutputPin(context, (SetOutputPin) semanticObject); 
				return; 
			case SpinCADPackage.SKIP:
				sequence_Skip(context, (Skip) semanticObject); 
				return; 
			case SpinCADPackage.SLIDER_LABEL_CHECK_BOX:
				sequence_SliderLabelCheckBox(context, (SliderLabelCheckBox) semanticObject); 
				return; 
			case SpinCADPackage.SLIDER_LABEL_SPINNER:
				sequence_SliderLabelSpinner(context, (SliderLabelSpinner) semanticObject); 
				return; 
			case SpinCADPackage.SPIN_BOOL:
				sequence_SpinBool(context, (SpinBool) semanticObject); 
				return; 
			case SpinCADPackage.SPIN_CHECK_BOX:
				sequence_SpinCheckBox(context, (SpinCheckBox) semanticObject); 
				return; 
			case SpinCADPackage.SPIN_COMBO_BOX:
				sequence_SpinComboBox(context, (SpinComboBox) semanticObject); 
				return; 
			case SpinCADPackage.SPIN_EQUATE:
				sequence_SpinEquate(context, (SpinEquate) semanticObject); 
				return; 
			case SpinCADPackage.SPIN_INT:
				sequence_SpinInt(context, (SpinInt) semanticObject); 
				return; 
			case SpinCADPackage.SPIN_RADIO_BUTTON:
				sequence_SpinRadioButton(context, (SpinRadioButton) semanticObject); 
				return; 
			case SpinCADPackage.SPIN_SLIDER_LABEL:
				sequence_SpinSliderLabel(context, (SpinSliderLabel) semanticObject); 
				return; 
			case SpinCADPackage.WRITE_ALLPASS:
				sequence_WriteAllpass(context, (WriteAllpass) semanticObject); 
				return; 
			case SpinCADPackage.WRITE_DELAY:
				sequence_WriteDelay(context, (WriteDelay) semanticObject); 
				return; 
			case SpinCADPackage.WRITE_REGISTER:
				sequence_WriteRegister(context, (WriteRegister) semanticObject); 
				return; 
			case SpinCADPackage.WRITE_REGISTER_HIGHSHELF:
				sequence_WriteRegisterHighshelf(context, (WriteRegisterHighshelf) semanticObject); 
				return; 
			case SpinCADPackage.WRITE_REGISTER_LOWSHELF:
				sequence_WriteRegisterLowshelf(context, (WriteRegisterLowshelf) semanticObject); 
				return; 
			case SpinCADPackage.XOR:
				sequence_Xor(context, (Xor) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     SpinElement returns Absa
	 *     Instruction returns Absa
	 *     Inst_X0 returns Absa
	 *     Absa returns Absa
	 *
	 * Constraint:
	 *     {Absa}
	 */
	protected void sequence_Absa(ISerializationContext context, Absa semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns And
	 *     Instruction returns And
	 *     Inst_B24 returns And
	 *     And returns And
	 *
	 * Constraint:
	 *     arg1=BINARY24
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_B24__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_B24__ARG1));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getArg1BINARY24ParserRuleCall_1_0(), semanticObject.getArg1());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pin returns AudioInput
	 *     InputPin returns AudioInput
	 *     AudioInput returns AudioInput
	 *
	 * Constraint:
	 *     (varName=ID (label=ID | label=STRING))
	 */
	protected void sequence_AudioInput(ISerializationContext context, AudioInput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pin returns AudioOutput
	 *     OutputPin returns AudioOutput
	 *     AudioOutput returns AudioOutput
	 *
	 * Constraint:
	 *     (varName=ID (label=ID | label=STRING))
	 */
	protected void sequence_AudioOutput(ISerializationContext context, AudioOutput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns ChorusReadDelay
	 *     Instruction returns ChorusReadDelay
	 *     ChorusReadDelay returns ChorusReadDelay
	 *
	 * Constraint:
	 *     (arg1=SPINREGISTER arg2=SPINCHOREGFLAGS arg3=SPINMEM)
	 */
	protected void sequence_ChorusReadDelay(ISerializationContext context, ChorusReadDelay semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.CHORUS_READ_DELAY__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.CHORUS_READ_DELAY__ARG1));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.CHORUS_READ_DELAY__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.CHORUS_READ_DELAY__ARG2));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.CHORUS_READ_DELAY__ARG3) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.CHORUS_READ_DELAY__ARG3));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChorusReadDelayAccess().getArg1SPINREGISTERParserRuleCall_2_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getChorusReadDelayAccess().getArg2SPINCHOREGFLAGSParserRuleCall_4_0(), semanticObject.getArg2());
		feeder.accept(grammarAccess.getChorusReadDelayAccess().getArg3SPINMEMParserRuleCall_6_0(), semanticObject.getArg3());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns ChorusReadValue
	 *     Instruction returns ChorusReadValue
	 *     ChorusReadValue returns ChorusReadValue
	 *
	 * Constraint:
	 *     arg1=SPINREGISTER
	 */
	protected void sequence_ChorusReadValue(ISerializationContext context, ChorusReadValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.CHORUS_READ_VALUE__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.CHORUS_READ_VALUE__ARG1));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChorusReadValueAccess().getArg1SPINREGISTERParserRuleCall_2_0(), semanticObject.getArg1());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns ChorusScaleOffset
	 *     Instruction returns ChorusScaleOffset
	 *     ChorusScaleOffset returns ChorusScaleOffset
	 *
	 * Constraint:
	 *     (arg1=ID arg2=SPINCHOREGFLAGS arg3=SPINDOUBLE)
	 */
	protected void sequence_ChorusScaleOffset(ISerializationContext context, ChorusScaleOffset semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.CHORUS_SCALE_OFFSET__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.CHORUS_SCALE_OFFSET__ARG1));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.CHORUS_SCALE_OFFSET__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.CHORUS_SCALE_OFFSET__ARG2));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.CHORUS_SCALE_OFFSET__ARG3) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.CHORUS_SCALE_OFFSET__ARG3));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChorusScaleOffsetAccess().getArg1IDTerminalRuleCall_2_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getChorusScaleOffsetAccess().getArg2SPINCHOREGFLAGSParserRuleCall_4_0(), semanticObject.getArg2());
		feeder.accept(grammarAccess.getChorusScaleOffsetAccess().getArg3SPINDOUBLEParserRuleCall_6_0(), semanticObject.getArg3());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns Clr
	 *     Instruction returns Clr
	 *     Inst_X0 returns Clr
	 *     Clr returns Clr
	 *
	 * Constraint:
	 *     {Clr}
	 */
	protected void sequence_Clr(ISerializationContext context, Clr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns Comment
	 *     Comment returns Comment
	 *
	 * Constraint:
	 *     remark=SC_COMMENT
	 */
	protected void sequence_Comment(ISerializationContext context, Comment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.COMMENT__REMARK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.COMMENT__REMARK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCommentAccess().getRemarkSC_COMMENTTerminalRuleCall_0(), semanticObject.getRemark());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pin returns ControlInput
	 *     InputPin returns ControlInput
	 *     ControlInput returns ControlInput
	 *
	 * Constraint:
	 *     (varName=ID (label=ID | label=STRING))
	 */
	protected void sequence_ControlInput(ISerializationContext context, ControlInput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pin returns ControlOutput
	 *     OutputPin returns ControlOutput
	 *     ControlOutput returns ControlOutput
	 *
	 * Constraint:
	 *     (varName=ID (label=ID | label=STRING))
	 */
	protected void sequence_ControlOutput(ISerializationContext context, ControlOutput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns DivideDouble
	 *     Macro returns DivideDouble
	 *     DivideDouble returns DivideDouble
	 *
	 * Constraint:
	 *     (varName=ID high=ID low=ID)
	 */
	protected void sequence_DivideDouble(ISerializationContext context, DivideDouble semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.DIVIDE_DOUBLE__VAR_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.DIVIDE_DOUBLE__VAR_NAME));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.DIVIDE_DOUBLE__HIGH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.DIVIDE_DOUBLE__HIGH));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.DIVIDE_DOUBLE__LOW) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.DIVIDE_DOUBLE__LOW));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDivideDoubleAccess().getVarNameIDTerminalRuleCall_1_0(), semanticObject.getVarName());
		feeder.accept(grammarAccess.getDivideDoubleAccess().getHighIDTerminalRuleCall_2_0(), semanticObject.getHigh());
		feeder.accept(grammarAccess.getDivideDoubleAccess().getLowIDTerminalRuleCall_3_0(), semanticObject.getLow());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns DivideInt
	 *     Macro returns DivideInt
	 *     DivideInt returns DivideInt
	 *
	 * Constraint:
	 *     (varName=ID high=ID low=INT)
	 */
	protected void sequence_DivideInt(ISerializationContext context, DivideInt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.DIVIDE_INT__VAR_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.DIVIDE_INT__VAR_NAME));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.DIVIDE_INT__HIGH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.DIVIDE_INT__HIGH));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.DIVIDE_INT__LOW) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.DIVIDE_INT__LOW));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDivideIntAccess().getVarNameIDTerminalRuleCall_1_0(), semanticObject.getVarName());
		feeder.accept(grammarAccess.getDivideIntAccess().getHighIDTerminalRuleCall_2_0(), semanticObject.getHigh());
		feeder.accept(grammarAccess.getDivideIntAccess().getLowINTTerminalRuleCall_3_0(), semanticObject.getLow());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns EqualsBool
	 *     Macro returns EqualsBool
	 *     EqualsBool returns EqualsBool
	 *
	 * Constraint:
	 *     (varName=ID value=BOOLEAN)
	 */
	protected void sequence_EqualsBool(ISerializationContext context, EqualsBool semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.EQUALS_BOOL__VAR_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.EQUALS_BOOL__VAR_NAME));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.EQUALS_BOOL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.EQUALS_BOOL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualsBoolAccess().getVarNameIDTerminalRuleCall_1_0(), semanticObject.getVarName());
		feeder.accept(grammarAccess.getEqualsBoolAccess().getValueBOOLEANParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns Equals
	 *     Macro returns Equals
	 *     Equals returns Equals
	 *
	 * Constraint:
	 *     (varName=ID value=SPINDOUBLE)
	 */
	protected void sequence_Equals(ISerializationContext context, Equals semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.EQUALS__VAR_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.EQUALS__VAR_NAME));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.EQUALS__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.EQUALS__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualsAccess().getVarNameIDTerminalRuleCall_1_0(), semanticObject.getVarName());
		feeder.accept(grammarAccess.getEqualsAccess().getValueSPINDOUBLEParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns Exp
	 *     Instruction returns Exp
	 *     Inst_S1_14_S1_10 returns Exp
	 *     Exp returns Exp
	 *
	 * Constraint:
	 *     (arg1=SPINDOUBLE arg2=SPINDOUBLE)
	 */
	protected void sequence_Exp(ISerializationContext context, Exp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_S1_14_S1_10__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_S1_14_S1_10__ARG1));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_S1_14_S1_10__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_S1_14_S1_10__ARG2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpAccess().getArg1SPINDOUBLEParserRuleCall_1_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getExpAccess().getArg2SPINDOUBLEParserRuleCall_3_0(), semanticObject.getArg2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns GetBaseAddress
	 *     Macro returns GetBaseAddress
	 *     GetBaseAddress returns GetBaseAddress
	 *
	 * Constraint:
	 *     {GetBaseAddress}
	 */
	protected void sequence_GetBaseAddress(ISerializationContext context, GetBaseAddress semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns GetDelayScaleControl
	 *     Macro returns GetDelayScaleControl
	 *     GetDelayScaleControl returns GetDelayScaleControl
	 *
	 * Constraint:
	 *     (ratio=ID length=ID offset=ID control=ID?)
	 */
	protected void sequence_GetDelayScaleControl(ISerializationContext context, GetDelayScaleControl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns GetInputDefault
	 *     Macro returns GetInputDefault
	 *     GetInputDefault returns GetInputDefault
	 *
	 * Constraint:
	 *     (label=ID variable=ID scale=SPINDOUBLE defaultVal=SPINDOUBLE)
	 */
	protected void sequence_GetInputDefault(ISerializationContext context, GetInputDefault semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.GET_INPUT_DEFAULT__LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.GET_INPUT_DEFAULT__LABEL));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.GET_INPUT_DEFAULT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.GET_INPUT_DEFAULT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.GET_INPUT_DEFAULT__SCALE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.GET_INPUT_DEFAULT__SCALE));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.GET_INPUT_DEFAULT__DEFAULT_VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.GET_INPUT_DEFAULT__DEFAULT_VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGetInputDefaultAccess().getLabelIDTerminalRuleCall_1_0(), semanticObject.getLabel());
		feeder.accept(grammarAccess.getGetInputDefaultAccess().getVariableIDTerminalRuleCall_2_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getGetInputDefaultAccess().getScaleSPINDOUBLEParserRuleCall_3_0(), semanticObject.getScale());
		feeder.accept(grammarAccess.getGetInputDefaultAccess().getDefaultValSPINDOUBLEParserRuleCall_4_0(), semanticObject.getDefaultVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns GetSamplesFromRatio
	 *     Macro returns GetSamplesFromRatio
	 *     GetSamplesFromRatio returns GetSamplesFromRatio
	 *
	 * Constraint:
	 *     (variable=ID ratio=SPINDOUBLE length=SPINDOUBLE)
	 */
	protected void sequence_GetSamplesFromRatio(ISerializationContext context, GetSamplesFromRatio semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.GET_SAMPLES_FROM_RATIO__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.GET_SAMPLES_FROM_RATIO__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.GET_SAMPLES_FROM_RATIO__RATIO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.GET_SAMPLES_FROM_RATIO__RATIO));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.GET_SAMPLES_FROM_RATIO__LENGTH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.GET_SAMPLES_FROM_RATIO__LENGTH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGetSamplesFromRatioAccess().getVariableIDTerminalRuleCall_1_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getGetSamplesFromRatioAccess().getRatioSPINDOUBLEParserRuleCall_2_0(), semanticObject.getRatio());
		feeder.accept(grammarAccess.getGetSamplesFromRatioAccess().getLengthSPINDOUBLEParserRuleCall_3_0(), semanticObject.getLength());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns IsElse
	 *     Macro returns IsElse
	 *     IsElse returns IsElse
	 *
	 * Constraint:
	 *     {IsElse}
	 */
	protected void sequence_IsElse(ISerializationContext context, IsElse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns IsEndif
	 *     Macro returns IsEndif
	 *     IsEndif returns IsEndif
	 *
	 * Constraint:
	 *     {IsEndif}
	 */
	protected void sequence_IsEndif(ISerializationContext context, IsEndif semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns IsEqualTo
	 *     Macro returns IsEqualTo
	 *     IsEqualTo returns IsEqualTo
	 *
	 * Constraint:
	 *     (variable=ID value=INT)
	 */
	protected void sequence_IsEqualTo(ISerializationContext context, IsEqualTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.IS_EQUAL_TO__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.IS_EQUAL_TO__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.IS_EQUAL_TO__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.IS_EQUAL_TO__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIsEqualToAccess().getVariableIDTerminalRuleCall_1_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getIsEqualToAccess().getValueINTTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns IsGreaterThan
	 *     Macro returns IsGreaterThan
	 *     IsGreaterThan returns IsGreaterThan
	 *
	 * Constraint:
	 *     (variable=ID value=INT)
	 */
	protected void sequence_IsGreaterThan(ISerializationContext context, IsGreaterThan semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.IS_GREATER_THAN__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.IS_GREATER_THAN__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.IS_GREATER_THAN__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.IS_GREATER_THAN__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIsGreaterThanAccess().getVariableIDTerminalRuleCall_1_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getIsGreaterThanAccess().getValueINTTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns IsLessThan
	 *     Macro returns IsLessThan
	 *     IsLessThan returns IsLessThan
	 *
	 * Constraint:
	 *     (variable=ID value=INT)
	 */
	protected void sequence_IsLessThan(ISerializationContext context, IsLessThan semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.IS_LESS_THAN__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.IS_LESS_THAN__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.IS_LESS_THAN__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.IS_LESS_THAN__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIsLessThanAccess().getVariableIDTerminalRuleCall_1_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getIsLessThanAccess().getValueINTTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns IsOr
	 *     Macro returns IsOr
	 *     IsOr returns IsOr
	 *
	 * Constraint:
	 *     (var1=ID var2=ID value=BOOLEAN)
	 */
	protected void sequence_IsOr(ISerializationContext context, IsOr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.IS_OR__VAR1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.IS_OR__VAR1));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.IS_OR__VAR2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.IS_OR__VAR2));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.IS_OR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.IS_OR__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIsOrAccess().getVar1IDTerminalRuleCall_1_0(), semanticObject.getVar1());
		feeder.accept(grammarAccess.getIsOrAccess().getVar2IDTerminalRuleCall_2_0(), semanticObject.getVar2());
		feeder.accept(grammarAccess.getIsOrAccess().getValueBOOLEANParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns IsPinConnected
	 *     Macro returns IsPinConnected
	 *     IsPinConnected returns IsPinConnected
	 *
	 * Constraint:
	 *     (arg1=ID | arg1=STRING)
	 */
	protected void sequence_IsPinConnected(ISerializationContext context, IsPinConnected semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns IsTrue
	 *     Macro returns IsTrue
	 *     IsTrue returns IsTrue
	 *
	 * Constraint:
	 *     variable=ID
	 */
	protected void sequence_IsTrue(ISerializationContext context, IsTrue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.IS_TRUE__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.IS_TRUE__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIsTrueAccess().getVariableIDTerminalRuleCall_1_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns Jam
	 *     Instruction returns Jam
	 *     Jam returns Jam
	 *
	 * Constraint:
	 *     arg1=ID
	 */
	protected void sequence_Jam(ISerializationContext context, Jam semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.JAM__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.JAM__ARG1));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJamAccess().getArg1IDTerminalRuleCall_1_0(), semanticObject.getArg1());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns Label
	 *     Label returns Label
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Label(ISerializationContext context, Label semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.LABEL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.LABEL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLabelAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns Ldax
	 *     Instruction returns Ldax
	 *     Inst_B6 returns Ldax
	 *     Ldax returns Ldax
	 *
	 * Constraint:
	 *     arg1=ID
	 */
	protected void sequence_Ldax(ISerializationContext context, Ldax semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_B6__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_B6__ARG1));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLdaxAccess().getArg1IDTerminalRuleCall_1_0(), semanticObject.getArg1());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns LoadRampLFO
	 *     Instruction returns LoadRampLFO
	 *     LoadRampLFO returns LoadRampLFO
	 *
	 * Constraint:
	 *     (arg1=SPINREGISTER arg2=SPINREGISTER arg3=SPINREGISTER)
	 */
	protected void sequence_LoadRampLFO(ISerializationContext context, LoadRampLFO semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.LOAD_RAMP_LFO__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.LOAD_RAMP_LFO__ARG1));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.LOAD_RAMP_LFO__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.LOAD_RAMP_LFO__ARG2));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.LOAD_RAMP_LFO__ARG3) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.LOAD_RAMP_LFO__ARG3));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLoadRampLFOAccess().getArg1SPINREGISTERParserRuleCall_1_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getLoadRampLFOAccess().getArg2SPINREGISTERParserRuleCall_3_0(), semanticObject.getArg2());
		feeder.accept(grammarAccess.getLoadRampLFOAccess().getArg3SPINREGISTERParserRuleCall_5_0(), semanticObject.getArg3());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns LoadSinLFO
	 *     Instruction returns LoadSinLFO
	 *     LoadSinLFO returns LoadSinLFO
	 *
	 * Constraint:
	 *     (arg1=SPINREGISTER arg2=SPINDOUBLE arg3=SPINDOUBLE)
	 */
	protected void sequence_LoadSinLFO(ISerializationContext context, LoadSinLFO semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.LOAD_SIN_LFO__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.LOAD_SIN_LFO__ARG1));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.LOAD_SIN_LFO__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.LOAD_SIN_LFO__ARG2));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.LOAD_SIN_LFO__ARG3) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.LOAD_SIN_LFO__ARG3));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLoadSinLFOAccess().getArg1SPINREGISTERParserRuleCall_1_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getLoadSinLFOAccess().getArg2SPINDOUBLEParserRuleCall_3_0(), semanticObject.getArg2());
		feeder.accept(grammarAccess.getLoadSinLFOAccess().getArg3SPINDOUBLEParserRuleCall_5_0(), semanticObject.getArg3());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns LogFreq2SliderLabel
	 *     Control returns LogFreq2SliderLabel
	 *     LogFreq2SliderLabel returns LogFreq2SliderLabel
	 *
	 * Constraint:
	 *     (
	 *         ename=ID 
	 *         (controlName=ID | controlName=STRING) 
	 *         (
	 *             minVal=SPINDOUBLE 
	 *             maxVal=SPINDOUBLE 
	 *             initVal=SPINDOUBLE 
	 *             multiplier=SPINDOUBLE 
	 *             precision=INT 
	 *             option=ID?
	 *         )?
	 *     )
	 */
	protected void sequence_LogFreq2SliderLabel(ISerializationContext context, LogFreq2SliderLabel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns LogFreqSliderLabel
	 *     Control returns LogFreqSliderLabel
	 *     LogFreqSliderLabel returns LogFreqSliderLabel
	 *
	 * Constraint:
	 *     (
	 *         ename=ID 
	 *         (controlName=ID | controlName=STRING) 
	 *         (
	 *             minVal=SPINDOUBLE 
	 *             maxVal=SPINDOUBLE 
	 *             initVal=SPINDOUBLE 
	 *             multiplier=SPINDOUBLE 
	 *             precision=INT 
	 *             option=ID?
	 *         )?
	 *     )
	 */
	protected void sequence_LogFreqSliderLabel(ISerializationContext context, LogFreqSliderLabel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns Log
	 *     Instruction returns Log
	 *     Log returns Log
	 *
	 * Constraint:
	 *     (arg1=SPINDOUBLE arg2=SPINDOUBLE)
	 */
	protected void sequence_Log(ISerializationContext context, Log semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.LOG__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.LOG__ARG1));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.LOG__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.LOG__ARG2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogAccess().getArg1SPINDOUBLEParserRuleCall_1_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getLogAccess().getArg2SPINDOUBLEParserRuleCall_3_0(), semanticObject.getArg2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns Maxx
	 *     Instruction returns Maxx
	 *     Inst_B6_S1_14 returns Maxx
	 *     Maxx returns Maxx
	 *
	 * Constraint:
	 *     (arg1=SPINREGISTER arg2=SPINDOUBLE)
	 */
	protected void sequence_Maxx(ISerializationContext context, Maxx semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_B6_S1_14__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_B6_S1_14__ARG1));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_B6_S1_14__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_B6_S1_14__ARG2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMaxxAccess().getArg1SPINREGISTERParserRuleCall_1_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getMaxxAccess().getArg2SPINDOUBLEParserRuleCall_3_0(), semanticObject.getArg2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns Mem
	 *     Mem returns Mem
	 *
	 * Constraint:
	 *     (buffer=ID length=SPINREGISTER)
	 */
	protected void sequence_Mem(ISerializationContext context, Mem semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.MEM__BUFFER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.MEM__BUFFER));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.MEM__LENGTH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.MEM__LENGTH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMemAccess().getBufferIDTerminalRuleCall_1_0(), semanticObject.getBuffer());
		feeder.accept(grammarAccess.getMemAccess().getLengthSPINREGISTERParserRuleCall_2_0(), semanticObject.getLength());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns MinusDouble
	 *     Macro returns MinusDouble
	 *     MinusDouble returns MinusDouble
	 *
	 * Constraint:
	 *     (varName=ID high=ID low=ID)
	 */
	protected void sequence_MinusDouble(ISerializationContext context, MinusDouble semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.MINUS_DOUBLE__VAR_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.MINUS_DOUBLE__VAR_NAME));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.MINUS_DOUBLE__HIGH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.MINUS_DOUBLE__HIGH));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.MINUS_DOUBLE__LOW) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.MINUS_DOUBLE__LOW));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMinusDoubleAccess().getVarNameIDTerminalRuleCall_1_0(), semanticObject.getVarName());
		feeder.accept(grammarAccess.getMinusDoubleAccess().getHighIDTerminalRuleCall_2_0(), semanticObject.getHigh());
		feeder.accept(grammarAccess.getMinusDoubleAccess().getLowIDTerminalRuleCall_3_0(), semanticObject.getLow());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns MultiplyDouble
	 *     Macro returns MultiplyDouble
	 *     MultiplyDouble returns MultiplyDouble
	 *
	 * Constraint:
	 *     (varName=ID high=ID low=ID)
	 */
	protected void sequence_MultiplyDouble(ISerializationContext context, MultiplyDouble semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.MULTIPLY_DOUBLE__VAR_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.MULTIPLY_DOUBLE__VAR_NAME));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.MULTIPLY_DOUBLE__HIGH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.MULTIPLY_DOUBLE__HIGH));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.MULTIPLY_DOUBLE__LOW) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.MULTIPLY_DOUBLE__LOW));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplyDoubleAccess().getVarNameIDTerminalRuleCall_1_0(), semanticObject.getVarName());
		feeder.accept(grammarAccess.getMultiplyDoubleAccess().getHighIDTerminalRuleCall_2_0(), semanticObject.getHigh());
		feeder.accept(grammarAccess.getMultiplyDoubleAccess().getLowIDTerminalRuleCall_3_0(), semanticObject.getLow());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns Mulx
	 *     Instruction returns Mulx
	 *     Inst_B6 returns Mulx
	 *     Mulx returns Mulx
	 *
	 * Constraint:
	 *     arg1=ID
	 */
	protected void sequence_Mulx(ISerializationContext context, Mulx semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_B6__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_B6__ARG1));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulxAccess().getArg1IDTerminalRuleCall_1_0(), semanticObject.getArg1());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns Not
	 *     Instruction returns Not
	 *     Inst_X0 returns Not
	 *     Not returns Not
	 *
	 * Constraint:
	 *     {Not}
	 */
	protected void sequence_Not(ISerializationContext context, Not semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns Offset
	 *     Offset returns Offset
	 *
	 * Constraint:
	 *     (name=ID length=INT)
	 */
	protected void sequence_Offset(ISerializationContext context, Offset semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.OFFSET__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.OFFSET__NAME));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.OFFSET__LENGTH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.OFFSET__LENGTH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOffsetAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOffsetAccess().getLengthINTTerminalRuleCall_2_0(), semanticObject.getLength());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns Or
	 *     Instruction returns Or
	 *     Inst_B24 returns Or
	 *     Or returns Or
	 *
	 * Constraint:
	 *     arg1=BINARY24
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_B24__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_B24__ARG1));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getArg1BINARY24ParserRuleCall_1_0(), semanticObject.getArg1());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     ((name=ID | name=STRING) color=STRING? pins+=Pin+ elements+=SpinElement+)
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns ReadChorusTap
	 *     Macro returns ReadChorusTap
	 *     ReadChorusTap returns ReadChorusTap
	 *
	 * Constraint:
	 *     (lfo=ID phase=INT ratio=ID length=ID offset=ID)
	 */
	protected void sequence_ReadChorusTap(ISerializationContext context, ReadChorusTap semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.READ_CHORUS_TAP__LFO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.READ_CHORUS_TAP__LFO));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.READ_CHORUS_TAP__PHASE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.READ_CHORUS_TAP__PHASE));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.READ_CHORUS_TAP__RATIO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.READ_CHORUS_TAP__RATIO));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.READ_CHORUS_TAP__LENGTH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.READ_CHORUS_TAP__LENGTH));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.READ_CHORUS_TAP__OFFSET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.READ_CHORUS_TAP__OFFSET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReadChorusTapAccess().getLfoIDTerminalRuleCall_1_0(), semanticObject.getLfo());
		feeder.accept(grammarAccess.getReadChorusTapAccess().getPhaseINTTerminalRuleCall_2_0(), semanticObject.getPhase());
		feeder.accept(grammarAccess.getReadChorusTapAccess().getRatioIDTerminalRuleCall_3_0(), semanticObject.getRatio());
		feeder.accept(grammarAccess.getReadChorusTapAccess().getLengthIDTerminalRuleCall_4_0(), semanticObject.getLength());
		feeder.accept(grammarAccess.getReadChorusTapAccess().getOffsetIDTerminalRuleCall_5_0(), semanticObject.getOffset());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns ReadDelayPointer
	 *     Instruction returns ReadDelayPointer
	 *     ReadDelayPointer returns ReadDelayPointer
	 *
	 * Constraint:
	 *     arg1=SPINDOUBLE
	 */
	protected void sequence_ReadDelayPointer(ISerializationContext context, ReadDelayPointer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.READ_DELAY_POINTER__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.READ_DELAY_POINTER__ARG1));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReadDelayPointerAccess().getArg1SPINDOUBLEParserRuleCall_1_0(), semanticObject.getArg1());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns ReadDelay
	 *     Instruction returns ReadDelay
	 *     Inst_B15_S1_9 returns ReadDelay
	 *     ReadDelay returns ReadDelay
	 *
	 * Constraint:
	 *     (arg1=SPINMEM arg2=SPINDOUBLE)
	 */
	protected void sequence_ReadDelay(ISerializationContext context, ReadDelay semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_B15_S1_9__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_B15_S1_9__ARG1));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_B15_S1_9__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_B15_S1_9__ARG2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReadDelayAccess().getArg1SPINMEMParserRuleCall_1_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getReadDelayAccess().getArg2SPINDOUBLEParserRuleCall_3_0(), semanticObject.getArg2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns ReadRegisterFilter
	 *     Instruction returns ReadRegisterFilter
	 *     Inst_B6_S1_14 returns ReadRegisterFilter
	 *     ReadRegisterFilter returns ReadRegisterFilter
	 *
	 * Constraint:
	 *     (arg1=SPINREGISTER arg2=SPINDOUBLE)
	 */
	protected void sequence_ReadRegisterFilter(ISerializationContext context, ReadRegisterFilter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_B6_S1_14__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_B6_S1_14__ARG1));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_B6_S1_14__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_B6_S1_14__ARG2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReadRegisterFilterAccess().getArg1SPINREGISTERParserRuleCall_1_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getReadRegisterFilterAccess().getArg2SPINDOUBLEParserRuleCall_3_0(), semanticObject.getArg2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns ReadRegister
	 *     Instruction returns ReadRegister
	 *     Inst_B6_S1_14 returns ReadRegister
	 *     ReadRegister returns ReadRegister
	 *
	 * Constraint:
	 *     (arg1=SPINREGISTER arg2=SPINDOUBLE)
	 */
	protected void sequence_ReadRegister(ISerializationContext context, ReadRegister semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_B6_S1_14__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_B6_S1_14__ARG1));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_B6_S1_14__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_B6_S1_14__ARG2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReadRegisterAccess().getArg1SPINREGISTERParserRuleCall_1_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getReadRegisterAccess().getArg2SPINDOUBLEParserRuleCall_3_0(), semanticObject.getArg2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SPINMEM returns SPINMEM
	 *
	 * Constraint:
	 *     (buffer=SPINBUF ((value=INT scale=ID?) | offset=[Offset|ID])?)
	 */
	protected void sequence_SPINMEM(ISerializationContext context, SPINMEM semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns ScaleOffset
	 *     Instruction returns ScaleOffset
	 *     Inst_S1_14_S1_10 returns ScaleOffset
	 *     ScaleOffset returns ScaleOffset
	 *
	 * Constraint:
	 *     (arg1=SPINDOUBLE arg2=SPINDOUBLE)
	 */
	protected void sequence_ScaleOffset(ISerializationContext context, ScaleOffset semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_S1_14_S1_10__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_S1_14_S1_10__ARG1));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_S1_14_S1_10__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_S1_14_S1_10__ARG2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScaleOffsetAccess().getArg1SPINDOUBLEParserRuleCall_1_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getScaleOffsetAccess().getArg2SPINDOUBLEParserRuleCall_3_0(), semanticObject.getArg2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns SemitonesToRmpRate
	 *     Macro returns SemitonesToRmpRate
	 *     SemitonesToRmpRate returns SemitonesToRmpRate
	 *
	 * Constraint:
	 *     (variable=ID semitones=SPINDOUBLE)
	 */
	protected void sequence_SemitonesToRmpRate(ISerializationContext context, SemitonesToRmpRate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.SEMITONES_TO_RMP_RATE__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.SEMITONES_TO_RMP_RATE__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.SEMITONES_TO_RMP_RATE__SEMITONES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.SEMITONES_TO_RMP_RATE__SEMITONES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSemitonesToRmpRateAccess().getVariableIDTerminalRuleCall_1_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getSemitonesToRmpRateAccess().getSemitonesSPINDOUBLEParserRuleCall_2_0(), semanticObject.getSemitones());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns SetChorusWidth
	 *     Macro returns SetChorusWidth
	 *     SetChorusWidth returns SetChorusWidth
	 *
	 * Constraint:
	 *     (varName=ID length=ID scale=ID)
	 */
	protected void sequence_SetChorusWidth(ISerializationContext context, SetChorusWidth semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.SET_CHORUS_WIDTH__VAR_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.SET_CHORUS_WIDTH__VAR_NAME));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.SET_CHORUS_WIDTH__LENGTH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.SET_CHORUS_WIDTH__LENGTH));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.SET_CHORUS_WIDTH__SCALE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.SET_CHORUS_WIDTH__SCALE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetChorusWidthAccess().getVarNameIDTerminalRuleCall_1_0(), semanticObject.getVarName());
		feeder.accept(grammarAccess.getSetChorusWidthAccess().getLengthIDTerminalRuleCall_2_0(), semanticObject.getLength());
		feeder.accept(grammarAccess.getSetChorusWidthAccess().getScaleIDTerminalRuleCall_3_0(), semanticObject.getScale());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns SetOutputPin
	 *     Macro returns SetOutputPin
	 *     SetOutputPin returns SetOutputPin
	 *
	 * Constraint:
	 *     ((pinName=ID | pinName=STRING) varName=ID)
	 */
	protected void sequence_SetOutputPin(ISerializationContext context, SetOutputPin semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns Skip
	 *     Instruction returns Skip
	 *     Skip returns Skip
	 *
	 * Constraint:
	 *     (flags=ID label=[Label|ID])
	 */
	protected void sequence_Skip(ISerializationContext context, Skip semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.SKIP__FLAGS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.SKIP__FLAGS));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.SKIP__LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.SKIP__LABEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSkipAccess().getFlagsIDTerminalRuleCall_1_0(), semanticObject.getFlags());
		feeder.accept(grammarAccess.getSkipAccess().getLabelLabelIDTerminalRuleCall_4_0_1(), semanticObject.eGet(SpinCADPackage.Literals.SKIP__LABEL, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns SliderLabelCheckBox
	 *     Control returns SliderLabelCheckBox
	 *     SliderLabelCheckBox returns SliderLabelCheckBox
	 *
	 * Constraint:
	 *     (
	 *         ename=ID 
	 *         (controlName=ID | controlName=STRING) 
	 *         (
	 *             minVal=SPINDOUBLE 
	 *             maxVal=SPINDOUBLE 
	 *             initVal=SPINDOUBLE 
	 *             multiplier=SPINDOUBLE 
	 *             precision=INT 
	 *             option=ID?
	 *         )?
	 *     )
	 */
	protected void sequence_SliderLabelCheckBox(ISerializationContext context, SliderLabelCheckBox semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns SliderLabelSpinner
	 *     Control returns SliderLabelSpinner
	 *     SliderLabelSpinner returns SliderLabelSpinner
	 *
	 * Constraint:
	 *     (
	 *         ename=ID 
	 *         (controlName=ID | controlName=STRING) 
	 *         (
	 *             minVal=SPINDOUBLE 
	 *             maxVal=SPINDOUBLE 
	 *             initVal=SPINDOUBLE 
	 *             multiplier=SPINDOUBLE 
	 *             precision=INT 
	 *             option=ID?
	 *         )?
	 *     )
	 */
	protected void sequence_SliderLabelSpinner(ISerializationContext context, SliderLabelSpinner semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns SpinBool
	 *     SpinBool returns SpinBool
	 *
	 * Constraint:
	 *     (label=ID value=BOOLEAN)
	 */
	protected void sequence_SpinBool(ISerializationContext context, SpinBool semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.SPIN_BOOL__LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.SPIN_BOOL__LABEL));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.SPIN_BOOL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.SPIN_BOOL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSpinBoolAccess().getLabelIDTerminalRuleCall_1_0(), semanticObject.getLabel());
		feeder.accept(grammarAccess.getSpinBoolAccess().getValueBOOLEANParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns SpinCheckBox
	 *     Control returns SpinCheckBox
	 *     SpinCheckBox returns SpinCheckBox
	 *
	 * Constraint:
	 *     (ename=ID (controlName=ID | controlName=STRING))
	 */
	protected void sequence_SpinCheckBox(ISerializationContext context, SpinCheckBox semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns SpinComboBox
	 *     Control returns SpinComboBox
	 *     SpinComboBox returns SpinComboBox
	 *
	 * Constraint:
	 *     (ename=ID optiona=STRING optionb=STRING (optionc=STRING (optiond=STRING (optione=STRING optionf=STRING?)?)?)?)
	 */
	protected void sequence_SpinComboBox(ISerializationContext context, SpinComboBox semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns SpinEquate
	 *     SpinEquate returns SpinEquate
	 *
	 * Constraint:
	 *     (ename=ID value=SPINDOUBLE)
	 */
	protected void sequence_SpinEquate(ISerializationContext context, SpinEquate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.SPIN_EQUATE__ENAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.SPIN_EQUATE__ENAME));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.SPIN_EQUATE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.SPIN_EQUATE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSpinEquateAccess().getEnameIDTerminalRuleCall_1_0(), semanticObject.getEname());
		feeder.accept(grammarAccess.getSpinEquateAccess().getValueSPINDOUBLEParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns SpinInt
	 *     SpinInt returns SpinInt
	 *
	 * Constraint:
	 *     (ename=ID value=INT)
	 */
	protected void sequence_SpinInt(ISerializationContext context, SpinInt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.SPIN_INT__ENAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.SPIN_INT__ENAME));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.SPIN_INT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.SPIN_INT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSpinIntAccess().getEnameIDTerminalRuleCall_1_0(), semanticObject.getEname());
		feeder.accept(grammarAccess.getSpinIntAccess().getValueINTTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns SpinRadioButton
	 *     Control returns SpinRadioButton
	 *     SpinRadioButton returns SpinRadioButton
	 *
	 * Constraint:
	 *     (ename=ID (controlName=ID | controlName=STRING))
	 */
	protected void sequence_SpinRadioButton(ISerializationContext context, SpinRadioButton semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns SpinSliderLabel
	 *     Control returns SpinSliderLabel
	 *     SpinSliderLabel returns SpinSliderLabel
	 *
	 * Constraint:
	 *     (
	 *         ename=ID 
	 *         (controlName=ID | controlName=STRING) 
	 *         (
	 *             minVal=SPINDOUBLE 
	 *             maxVal=SPINDOUBLE 
	 *             initVal=SPINDOUBLE 
	 *             multiplier=SPINDOUBLE 
	 *             precision=INT 
	 *             option=ID?
	 *         )?
	 *     )
	 */
	protected void sequence_SpinSliderLabel(ISerializationContext context, SpinSliderLabel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns WriteAllpass
	 *     Instruction returns WriteAllpass
	 *     Inst_B15_S1_9 returns WriteAllpass
	 *     WriteAllpass returns WriteAllpass
	 *
	 * Constraint:
	 *     (arg1=SPINMEM arg2=SPINDOUBLE)
	 */
	protected void sequence_WriteAllpass(ISerializationContext context, WriteAllpass semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_B15_S1_9__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_B15_S1_9__ARG1));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_B15_S1_9__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_B15_S1_9__ARG2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWriteAllpassAccess().getArg1SPINMEMParserRuleCall_1_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getWriteAllpassAccess().getArg2SPINDOUBLEParserRuleCall_3_0(), semanticObject.getArg2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns WriteDelay
	 *     Instruction returns WriteDelay
	 *     Inst_B15_S1_9 returns WriteDelay
	 *     WriteDelay returns WriteDelay
	 *
	 * Constraint:
	 *     (arg1=SPINMEM arg2=SPINDOUBLE)
	 */
	protected void sequence_WriteDelay(ISerializationContext context, WriteDelay semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_B15_S1_9__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_B15_S1_9__ARG1));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_B15_S1_9__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_B15_S1_9__ARG2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWriteDelayAccess().getArg1SPINMEMParserRuleCall_1_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getWriteDelayAccess().getArg2SPINDOUBLEParserRuleCall_3_0(), semanticObject.getArg2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns WriteRegisterHighshelf
	 *     Instruction returns WriteRegisterHighshelf
	 *     Inst_B6_S1_14 returns WriteRegisterHighshelf
	 *     WriteRegisterHighshelf returns WriteRegisterHighshelf
	 *
	 * Constraint:
	 *     (arg1=SPINREGISTER arg2=SPINDOUBLE)
	 */
	protected void sequence_WriteRegisterHighshelf(ISerializationContext context, WriteRegisterHighshelf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_B6_S1_14__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_B6_S1_14__ARG1));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_B6_S1_14__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_B6_S1_14__ARG2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWriteRegisterHighshelfAccess().getArg1SPINREGISTERParserRuleCall_1_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getWriteRegisterHighshelfAccess().getArg2SPINDOUBLEParserRuleCall_3_0(), semanticObject.getArg2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns WriteRegisterLowshelf
	 *     Instruction returns WriteRegisterLowshelf
	 *     Inst_B6_S1_14 returns WriteRegisterLowshelf
	 *     WriteRegisterLowshelf returns WriteRegisterLowshelf
	 *
	 * Constraint:
	 *     (arg1=SPINREGISTER arg2=SPINDOUBLE)
	 */
	protected void sequence_WriteRegisterLowshelf(ISerializationContext context, WriteRegisterLowshelf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_B6_S1_14__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_B6_S1_14__ARG1));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_B6_S1_14__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_B6_S1_14__ARG2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWriteRegisterLowshelfAccess().getArg1SPINREGISTERParserRuleCall_1_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getWriteRegisterLowshelfAccess().getArg2SPINDOUBLEParserRuleCall_3_0(), semanticObject.getArg2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns WriteRegister
	 *     Instruction returns WriteRegister
	 *     Inst_B6_S1_14 returns WriteRegister
	 *     WriteRegister returns WriteRegister
	 *
	 * Constraint:
	 *     (arg1=SPINREGISTER arg2=SPINDOUBLE)
	 */
	protected void sequence_WriteRegister(ISerializationContext context, WriteRegister semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_B6_S1_14__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_B6_S1_14__ARG1));
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_B6_S1_14__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_B6_S1_14__ARG2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWriteRegisterAccess().getArg1SPINREGISTERParserRuleCall_1_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getWriteRegisterAccess().getArg2SPINDOUBLEParserRuleCall_3_0(), semanticObject.getArg2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpinElement returns Xor
	 *     Instruction returns Xor
	 *     Inst_B24 returns Xor
	 *     Xor returns Xor
	 *
	 * Constraint:
	 *     arg1=BINARY24
	 */
	protected void sequence_Xor(ISerializationContext context, Xor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpinCADPackage.Literals.INST_B24__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpinCADPackage.Literals.INST_B24__ARG1));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXorAccess().getArg1BINARY24ParserRuleCall_1_0(), semanticObject.getArg1());
		feeder.finish();
	}
	
	
}
